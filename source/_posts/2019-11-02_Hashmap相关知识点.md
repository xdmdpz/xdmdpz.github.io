---
title: Hashmap相关知识点
date: 2019-11-02 13:40:40
tags: 面试
header-img: "/img/if/IMG_1208.jpg"
subtitle: "记录一下"
---

整理下收集来的资料

### 什么是Map

- Map就是用于存储键值对（<key,value>）的集合类
- map没有重复的 key
- 每个 key 只能对应一个 value, 多个 key 可以对应一个 value
- 传入key值相同的键值对，将作为覆盖处理

### 什么哈希（Hash）

- Hash把任意长度的输入，通过哈希函数，变换成固定长度的输出
- 数据的值叫做预映射
- 哈希函数是散列算法的一种实现（例如HashCode()）
- 输出的值就是HashCode
- 这个计算过程就叫做Hash/哈希/散列

### 什么是HashMap

- HashMap是用哈希表（数组加单链表）+红黑树（1.8加入）实现的Map

  继承AbstractMap，实现了Map，Serializable且线程不安全的Map

- 通过拉链法来解决哈希冲突，将发生碰撞的节点连接成一条单链表

- 允许null键和null值

- 不保证有序，即元素的插入和读取顺序不保证一致

- 也不保证元素的顺序始终不变，在扩容时，元素的顺序会重新被打乱

### 简述jdk7和jdk8中Hash的区别

- jdk7 数组+单链表 jdk8 数组+(单链表+红黑树) 

- jdk7 链表头插 jdk8 链表尾插 

  JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题

- jdk7 先扩容再put jdk8 先put再扩容

  先扩容再put就是不管当前插入的值所属的桶是不是空，都先扩容，会造成无效扩容；先put在扩容，会在put时发现是否当前桶为空，即是否发生hash冲突，如果发生了就扩容，不发生就等下一次插入冲突或大于阀值时扩容

- jdk7 计算hash运算多 jdk8 计算hash运算少

- jdk7 受rehash影响 jdk8 调整后是(原位置)or(原位置+旧容量)

- JDK8增加了Spliterator进行遍历

### 源码分析

**哈希函数**计算结果越分散均匀，**哈希碰撞**的概率就越小，map的存取效率就会越高。

**哈希表**长度越长，空间成本越大，**哈希函数**计算结果越分散均匀。

**扩容机制**和**哈希函数**越合理， 空间成本越小，哈希函数计算结果越分散均匀。

**负载因子**越大（长度一定），最大结点容量越大，**resize**次数越少，空间成本越小，map的存取效率就会越高。

桶数组**初始容量**（长度）越大（加载因子一定），最大结点容量越大，resize次数越少，空间成本越大，map的存取效率就会越高

从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化。

```java
 int threshold;             // 最大node结点（键值对）容量，threshold = CAPACITY * LoadFactor，超过这个数目就重新resize(扩容)，扩容后的threshold是之前的两倍。
 final float loadFactor;    // 加载因子(HashMap默认值是0.75，建议不要修改)
 int modCount;              // 记录HashMap内部结构发生变化的次数，强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。
 int size,CAPACITY;      // CAPACITY是桶数组的容量（桶的多少）(默认值是16)，扩容后也是之前的两倍，size是HashMap中实际存在的键值对数量
```

#### 为什么加入红黑树

即使负载因子和哈希函数设计的再合理，也免不了会出现拉链过长（桶内结点过多）的情况，一旦出现拉链过长，则会严重影响HashMap的性能。

于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率，利用红黑树快速增删改查的特点提高HashMap的性能




#### 为什么在JDK1.8中进行对HashMap优化的时候，把链表转化为红黑树的阈值是8,而不是7或者不是20呢（面试蘑菇街问过）？

如果选择6和8（如果链表小于等于6树还原转为链表，大于等于8转为树），中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。
还有一点重要的就是由于treenodes的大小大约是常规节点的两倍，因此我们仅在容器包含足够的节点以保证使用时才使用它们，当它们变得太小（由于移除或调整大小）时，它们会被转换回普通的node节点，容器中节点分布在hash桶中的频率遵循泊松分布，桶的长度超过8的概率非常非常小。所以作者应该是根据概率统计而选择了8作为阀值


#### 为什么在JDK1.7的时候是先进行扩容后进行插入，而在JDK1.8的时候则是先插入后进行扩容的呢？

其实就是当这个Map中实际插入的键值对的值的大小如果大于这个默认的阈值的时候（初始是16*0.75=12）的时候才会触发扩容，

```java
//其实就是当这个Map中实际插入的键值对的值的大小如果大于这个默认的阈值的时候（初始是16*0.75=12）的时候才会触发扩容，
//这个是在JDK1.8中的先插入后扩容
if (++size > threshold)
            resize();

```

其实这个问题也是JDK8对HashMap中，主要是因为对链表转为红黑树进行的优化，因为你插入这个节点的时候有可能是普通链表节点，也有可能是红黑树节点，但是为什么1.8之后HashMap变为先插入后扩容的原因，我也有点不是很理解？欢迎来讨论这个问题？
但是在JDK1.7中的话，是先进行扩容后进行插入的，就是当你发现你插入的桶是不是为空，如果不为空说明存在值就发生了hash冲突，那么就必须得扩容，但是如果不发生Hash冲突的话，说明当前桶是空的（后面并没有挂有链表），那就等到下一次发生Hash冲突的时候在进行扩容，但是当如果以后都没有发生hash冲突产生，那么就不会进行扩容了，减少了一次无用扩容，也减少了内存的使用


#####  HashMap 1.7 / 1.8差异分析

| 差异种类                   | HashMap 1.7                                                  | HashMap 1.8                                                  |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据结构                   | 数组+链表                                                    | 数组+链表+红黑树，当链表lenth>8则转换为红黑树，在resize()后，所有数据位置会重新计算，如果红黑树的元素个数<=6则转回链表 |
| 初始化方式                 | inflateTable()                                               | resize()                                                     |
| hash计算方式               | hashCode()  , 扰动处理（4次位运算+5次异或运算）              | hashCode()  , 扰动处理（1次位运算+1次异或运算）              |
| 数据存放方式               | 无冲突时存放数组，有冲突时存放单链表                         | 无冲突时存放数组，有冲突存放链表（长度<8）或红黑树(长度>=8)  |
| 数据插入方式               | 头插法（将原有数据后移一位）                                 | 尾插法（直接插入链表或红黑树尾部）                           |
| 扩容后存储位置的计算方式   | 全部重新计算（hashCode()>扰动处理>&(lenth-1)）               | 原位置/原位置+老table.lenth                                  |
| 扩容后转移老数据的方式     | 头插法（原数据后移一位，会出现逆序，环形链表，死循环等问题） | 尾插法（不会出现逆序，环形列表，死循环等问题）               |
| 扩容时机                   | 先判断>阀值扩容后再插入                                      | 先插入数据然后判断>阀值扩容                                  |
| 旧数据转移时的位置计算时机 | 单独计算                                                     | 转移时统一计算                                               |



 

 

 参考文章

CSDN博主「依本多情」https://blog.csdn.net/qq_36520235/article/details/82417949

CSDN博主「酒吧七」https://blog.csdn.net/qq_36711757/article/details/80394272